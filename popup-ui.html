<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title data-i18n="popup.title">gengo - テキスト処理</title>
    <!-- Bootstrap CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet">
    <!-- Bootstrap Icons -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.1/font/bootstrap-icons.css" rel="stylesheet">
    <style>
        /* ショートカットキーのツールチップスタイル */
        .shortcut-tooltip {
            position: absolute;
            background-color: rgba(0, 0, 0, 0.85);
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 11px;
            font-family: monospace;
            pointer-events: none;
            z-index: 10000;
            white-space: nowrap;
            opacity: 0;
            transition: opacity 0.2s ease-in-out;
        }

        .shortcut-tooltip.show {
            opacity: 1;
        }

        /* ボタンにホバー時のポジション調整 */
        .btn-with-shortcut {
            position: relative;
        }
    </style>
</head>

<body>
    <div class="container-fluid">
        <!-- AI処理中画面 -->
        <div id="processing"
            style="position:absolute; top:0; left:0; width:100%; height:100%; display:none; align-items:center; justify-content:center; padding:1rem; z-index:1050; background-color:rgba(255,255,255,0.95);">
            <div class="text-center" style="-webkit-app-region: no-drag; min-width:220px; width:100%; max-width:600px;">
                <div class="spinner-border" role="status">
                    <span class="visually-hidden">Loading...</span>
                </div>
                <div class="mt-3">
                    <div id="processingAction" data-i18n="popup.processing">処理中...</div>
                </div>

                <!-- ストリーミング結果表示エリア -->
                <div id="streamingResult" class="mt-4 p-3 text-start"
                    style="display:none; background-color:rgba(255,255,255,0.8); border-radius:8px; max-height:300px; overflow-y:auto; word-wrap:break-word; white-space:pre-wrap; font-size:0.9rem; color:#333;">
                </div>
            </div>
        </div>

        <!-- 結果表示画面 -->
        <div id="resultDisplay" class="d-none">
            <div class="mt-3 mb-3 drag-region">
                <h6 class="text-center" data-i18n="popup.result.title">処理結果</h6>
            </div>

            <div class="row">
                <div class="col-sm-6 col-md-6 mb-3">
                    <label class="form-label small" data-i18n="popup.result.original_text">元のテキスト</label>
                    <div class="form-control" id="originalText" readonly
                        style="word-wrap: break-word; white-space: pre-wrap;"></div>
                </div>

                <div class="col-sm-6 col-md-6 mb-3">
                    <label class="form-label small" data-i18n="popup.result.processed_text">処理結果</label>
                    <div class="form-control" id="processedText" readonly
                        style="word-wrap: break-word; white-space: pre-wrap;"></div>


                </div>
            </div>

            <div class="d-grid gap-2 d-sm-flex justify-content-sm-end mb-2">
                <button class="btn btn-outline-dark btn-with-shortcut" id="applyBtn" data-i18n="popup.apply"
                    data-shortcut="⌘+Enter">適用</button>
                <button class="btn btn-secondary btn-with-shortcut" id="rejectBtn" data-i18n="popup.reject"
                    data-shortcut="Esc">キャンセル</button>
            </div>
        </div>

        <!-- オンデマンドプロンプト入力画面 -->
        <div id="onDemandPromptInput" class="d-none">
            <div class="mt-3 mb-3 drag-region">
                <h6 class="text-center">オンデマンドプロンプト入力</h6>
            </div>

            <div class="mb-3" style="display:none">
                <label class="form-label small">選択されたテキスト</label>
                <div class="form-control" id="selectedTextDisplay" readonly
                    style="word-wrap: break-word; white-space: pre-wrap; max-height: 100px; overflow-y: auto;"></div>
            </div>

            <div class="mb-3">
                <label class="form-label small">処理指示を入力してください</label>
                <textarea class="form-control" id="userPromptInput" rows="4"
                    placeholder="例: 英語に翻訳して、絵文字だけで表現して、要約して、など"></textarea>
            </div>

            <div class="d-grid gap-2 d-sm-flex justify-content-sm-end mb-2">
                <button class="btn btn-primary btn-with-shortcut" id="processBtn" data-shortcut="⌘+Enter">処理実行</button>
                <button class="btn btn-secondary btn-with-shortcut" id="cancelPromptBtn"
                    data-shortcut="Esc">キャンセル</button>
            </div>
        </div>

        <!-- テキスト生成モード入力画面 -->
        <div id="textGenerationInput" class="d-none">
            <div class="mt-3 mb-3 drag-region">
                <h6 class="text-center">テキスト生成モード</h6>
            </div>

            <div class="mb-3">
                <label class="form-label small">生成したいテキストの指示を入力してください</label>
                <textarea class="form-control" id="generationPromptInput" rows="4"
                    placeholder="例: 400字の納期文を生成して、プログラミング学習について解説文を書いて、など"></textarea>
            </div>

            <div class="d-grid gap-2 d-sm-flex justify-content-sm-end mb-2">
                <button class="btn btn-primary btn-with-shortcut" id="textGenerateBtn"
                    data-shortcut="⌘+Enter">テキスト生成</button>
                <button class="btn btn-secondary btn-with-shortcut" id="cancelGenerationBtn"
                    data-shortcut="Esc">キャンセル</button>
            </div>
        </div>

    </div>

    <!-- Bootstrap JS -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"></script>

    <script>
        // i18n初期化関数
        let i18nMap = {};
        // 選択されたテキストを保存するグローバル変数
        let currentSelectedText = '';

        async function initI18n() {
            try {
                const i18nData = await window.electronAPI.getI18nData();
                i18nMap = i18nData;
                translatePage();
            } catch (error) {
                console.error('i18n初期化エラー:', error);
            }
        }

        function translatePage() {
            document.querySelectorAll('[data-i18n]').forEach(element => {
                const key = element.getAttribute('data-i18n');
                const translation = t(key);
                if (translation && translation !== key) {
                    if (element.tagName === 'INPUT' && element.type === 'button') {
                        element.value = translation;
                    } else {
                        element.textContent = translation;
                    }
                }
            });
        }

        function t(key) {
            const keys = key.split('.');
            let value = i18nMap;
            for (const k of keys) {
                if (value && typeof value === 'object' && k in value) {
                    value = value[k];
                } else {
                    return key;
                }
            }
            return value || key;
        }

        document.addEventListener('DOMContentLoaded', async () => {
            console.log('popup-ui.html DOMContentLoaded');
            await initI18n();

            // 共通のキャンセル処理
            function handleCancel() {
                if (window.electronAPI) {
                    window.electronAPI.closeWindow();
                }
            }

            // 共通の実行処理
            function handleExecute() {
                const resultDisplay = document.getElementById('resultDisplay');
                const onDemandPromptInput = document.getElementById('onDemandPromptInput');
                const textGenerationInput = document.getElementById('textGenerationInput');

                if (!resultDisplay.classList.contains('d-none')) {
                    // 結果表示画面の場合：適用処理
                    if (window.electronAPI) {
                        window.electronAPI.applyResult();
                    } else {
                        console.log('デバッグモード: 適用処理');
                    }
                } else if (!onDemandPromptInput.classList.contains('d-none')) {
                    // オンデマンドプロンプト入力画面の場合：処理実行
                    const userPrompt = document.getElementById('userPromptInput').value.trim();
                    if (userPrompt) {
                        showProcessingScreen('processing');
                        if (window.electronAPI) {
                            window.electronAPI.processOnDemandPrompt(userPrompt, currentSelectedText);
                        }
                    }
                } else if (!textGenerationInput.classList.contains('d-none')) {
                    // テキスト生成入力画面の場合：テキスト生成
                    const generationPrompt = document.getElementById('generationPromptInput').value.trim();
                    if (generationPrompt) {
                        showProcessingScreen('generation');
                        if (window.electronAPI) {
                            window.electronAPI.processTextGeneration(generationPrompt);
                        }
                    } else {
                        alert('テキスト生成の指示を入力してください。');
                    }
                }
            }

            // キーボードショートカット設定
            document.addEventListener('keydown', (event) => {
                // ESCキーでキャンセル処理
                if (event.key === 'Escape') {
                    event.preventDefault();
                    handleCancel();
                    return;
                }

                // Cmd+Enter (Mac) または Ctrl+Enter (Windows/Linux)で実行処理
                if ((event.metaKey || event.ctrlKey) && event.key === 'Enter') {
                    event.preventDefault();
                    handleExecute();
                    return;
                }
            });            // ボタンイベント設定
            document.getElementById('applyBtn').addEventListener('click', () => {
                window.electronAPI.applyResult();
            });

            document.getElementById('rejectBtn').addEventListener('click', handleCancel);

            document.getElementById('processBtn').addEventListener('click', handleExecute);

            document.getElementById('cancelPromptBtn').addEventListener('click', handleCancel);

            document.getElementById('textGenerateBtn').addEventListener('click', () => {
                handleExecute();
            });

            document.getElementById('cancelGenerationBtn').addEventListener('click', handleCancel);

            // ショートカットキーのツールチップ機能を初期化
            initShortcutTooltips();
        });

        // ショートカットキーのツールチップ機能
        function initShortcutTooltips() {
            // ツールチップ要素を作成
            const tooltip = document.createElement('div');
            tooltip.className = 'shortcut-tooltip';
            document.body.appendChild(tooltip);

            let currentButton = null;

            // すべての.btn-with-shortcutボタンにイベントリスナーを追加
            document.querySelectorAll('.btn-with-shortcut').forEach(button => {
                button.addEventListener('mouseenter', (event) => {
                    const shortcut = button.getAttribute('data-shortcut');
                    if (shortcut) {
                        currentButton = button;
                        tooltip.textContent = shortcut;
                        tooltip.classList.add('show');
                        updateTooltipPosition(event, tooltip);
                    }
                });

                button.addEventListener('mousemove', (event) => {
                    if (currentButton === button) {
                        updateTooltipPosition(event, tooltip);
                    }
                });

                button.addEventListener('mouseleave', () => {
                    if (currentButton === button) {
                        tooltip.classList.remove('show');
                        currentButton = null;
                    }
                });
            });
        }

        // ツールチップの位置を更新
        function updateTooltipPosition(event, tooltip) {
            const offsetX = 10;
            const offsetY = -30;
            tooltip.style.left = (event.clientX + offsetX) + 'px';
            tooltip.style.top = (event.clientY + offsetY) + 'px';
        }

        // デバッグモード設定関数
        // 処理中画面表示
        async function showProcessingScreen(action) {
            // 他の全ての画面を非表示にする
            document.getElementById('resultDisplay').classList.add('d-none');
            document.getElementById('onDemandPromptInput').classList.add('d-none');
            document.getElementById('textGenerationInput').classList.add('d-none');

            // 処理中画面を表示
            const processingElement = document.getElementById('processing');
            processingElement.style.display = 'flex';
            processingElement.style.visibility = 'visible';

            // ストリーミング結果エリアをリセット
            const streamingResult = document.getElementById('streamingResult');
            if (streamingResult) {
                streamingResult.textContent = '';
                streamingResult.style.display = 'none';
            }

            let processingMessage;
            if (action === 'generation') {
                processingMessage = 'テキスト生成中...';
            } else {
                processingMessage = (window.electronAPI && await t(`popup.processing_messages.${action.replace('-', '_')}`)) ||
                    (window.electronAPI && await t('popup.processing')) ||
                    '処理中...';
            }
            document.getElementById('processingAction').textContent = processingMessage;
        }

        // ストリーミング結果を更新（リアルタイム表示）
        window.updateStreamingResult = function (text) {
            const streamingResult = document.getElementById('streamingResult');
            if (streamingResult) {
                streamingResult.textContent = text;
                streamingResult.style.display = 'block';
                // 自動スクロール（最新のテキストが見えるように）
                streamingResult.scrollTop = streamingResult.scrollHeight;
            }
        };

        // 結果表示スタイルをリセット（テキスト生成モード用スタイルを元に戻す）
        function resetResultDisplayStyle() {
            console.log('resetResultDisplayStyle開始');
            const originalTextSection = document.querySelector('#resultDisplay .row .col-sm-6:first-child');
            const processedTextSection = document.querySelector('#resultDisplay .row .col-sm-6:last-child');

            if (originalTextSection && processedTextSection) {
                // 元のテキストセクションを表示に戻す
                originalTextSection.style.display = 'block';
                // 処理結果セクションのスタイルをリセット
                processedTextSection.style.width = '';
                processedTextSection.style.maxWidth = '';
                processedTextSection.style.flex = '';
                console.log('resetResultDisplayStyle完了');
            } else {
                console.log('resetResultDisplayStyle: セクションが見つかりません');
            }
        }

        // 結果表示画面表示
        async function showResultScreen(originalText, resultText) {
            console.log('showResultScreen開始:', { originalText, resultText });

            document.getElementById('processing').style.display = 'none';
            document.getElementById('resultDisplay').classList.remove('d-none');
            document.getElementById('onDemandPromptInput').classList.add('d-none');
            document.getElementById('textGenerationInput').classList.add('d-none');

            // テキスト生成モード用のスタイルをリセット
            resetResultDisplayStyle();

            document.getElementById('originalText').textContent = originalText;
            document.getElementById('processedText').textContent = resultText;

            // 「適用」ボタンをデフォルトに戻す
            const applyBtn = document.getElementById('applyBtn');
            if (applyBtn) {
                const applyText = (window.electronAPI && await t('popup.apply')) || '適用';
                applyBtn.textContent = applyText;
                applyBtn.className = 'btn btn-outline-dark';
                console.log('適用ボタン設定完了:', applyText);
            }
            console.log('showResultScreen完了');
        }

        // オンデマンドプロンプト入力画面表示
        function showOnDemandPromptScreen(selectedText) {
            console.log('showOnDemandPromptScreen開始:', selectedText);

            // 選択されたテキストを保存
            currentSelectedText = selectedText;

            document.getElementById('processing').style.display = 'none';
            document.getElementById('resultDisplay').classList.add('d-none');
            document.getElementById('onDemandPromptInput').classList.remove('d-none');
            document.getElementById('textGenerationInput').classList.add('d-none');

            document.getElementById('selectedTextDisplay').textContent = selectedText;
            document.getElementById('userPromptInput').value = '';

            // テキストエリアにフォーカス
            setTimeout(() => {
                const textarea = document.getElementById('userPromptInput');
                if (textarea) {
                    textarea.focus();
                    console.log('オンデマンドプロンプト入力フィールドにフォーカス設定完了');
                }
            }, 100);
            console.log('showOnDemandPromptScreen完了');
        }

        // メインプロセスからの呼び出し
        window.showProcessingResult = async (originalText, resultText) => {
            await showResultScreen(originalText, resultText);
        };

        window.showOnDemandPromptInput = (selectedText) => {
            showOnDemandPromptScreen(selectedText);
        };

        window.showProcessingMessage = (message, type = 'info') => {
            // 処理中画面を非表示
            document.getElementById('processing').style.display = 'none';
            document.getElementById('resultDisplay').classList.add('d-none');
            document.getElementById('onDemandPromptInput').classList.add('d-none');
            document.getElementById('textGenerationInput').classList.add('d-none');

            // メッセージを表示
            alert(message);

            // ウィンドウを閉じる
            if (window.electronAPI) {
                window.electronAPI.closeWindow();
            }
        };

        // メインプロセスからのテキスト生成モード信号を受信（すでに上記のDOMContentLoadedで設定済み）

        // テキスト生成モード表示
        function showTextGenerationMode() {
            // 全ての他のセクションを強制的に非表示にする
            const processingElement = document.getElementById('processing');
            processingElement.style.display = 'none';
            processingElement.style.visibility = 'hidden';

            document.getElementById('resultDisplay').classList.add('d-none');
            document.getElementById('onDemandPromptInput').classList.add('d-none');

            // テキスト生成入力セクションを表示
            const textGenElement = document.getElementById('textGenerationInput');
            textGenElement.classList.remove('d-none');
            textGenElement.style.display = 'block';

            // フラグ設定
            window.isTextGenerationMode = true;
            window.isOnDemandMode = false;

            // テキストエリアをクリア（以前の状態をリセット）
            const textarea = document.getElementById('generationPromptInput');
            if (textarea) {
                textarea.value = ''; // クリア
                setTimeout(() => {
                    textarea.focus();
                }, 150);
            }
        }

        // テキスト生成モード関数をwindowオブジェクトに公開
        window.showTextGenerationMode = showTextGenerationMode;

        // テキスト生成結果表示
        window.showTextGenerationResult = (generatedText) => {
            // 処理中画面を非表示
            const processingElement = document.getElementById('processing');
            processingElement.style.display = 'none';
            processingElement.style.visibility = 'hidden';

            // 入力画面を非表示
            document.getElementById('textGenerationInput').classList.add('d-none');
            document.getElementById('onDemandPromptInput').classList.add('d-none');

            // テキスト生成モードでは元のテキストセクションを完全に非表示にする
            const originalTextSection = document.querySelector('#resultDisplay .row .col-sm-6:first-child');
            const processedTextSection = document.querySelector('#resultDisplay .row .col-sm-6:last-child');

            if (originalTextSection && processedTextSection) {
                // 元のテキストセクションを完全に非表示
                originalTextSection.style.display = 'none';
                // 処理結果セクションを全幅にして単独表示
                processedTextSection.style.width = '100%';
                processedTextSection.style.maxWidth = '100%';
                processedTextSection.style.flex = '0 0 100%';
            }

            // 結果表示
            document.getElementById('processedText').textContent = generatedText;

            // テキスト生成モードでは「適用」ボタンの文言を変更
            const applyBtn = document.getElementById('applyBtn');
            if (applyBtn) {
                applyBtn.textContent = 'カーソル位置に挿入';
                applyBtn.className = 'btn btn-primary';
            }

            // 結果表示画面を表示
            document.getElementById('resultDisplay').classList.remove('d-none');
        };
    </script>
</body>

</html>